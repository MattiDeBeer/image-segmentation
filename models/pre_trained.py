import torchimport torch.nn as nnfrom models.processing_blocks import ConvBlockDownsample, ConvBlockUpsampleSkip, ConvBlock, ConvBlockUpsamplefrom models.autoencoder import Autoencoder # Segmentaion decoder using pre-trained fixed encoderclass SegmentationDecoderSkip(nn.Module):    def __init__(self, out_channels):        super().__init__()        self.dec1 = ConvBlockUpsampleSkip(1024, 512)  # Uses skip from enc3 or enc4        self.dec2 = ConvBlockUpsampleSkip(512, 256)        self.dec3 = ConvBlockUpsampleSkip(256, 128)        self.dec4 = ConvBlockUpsampleSkip(128, 64)        self.out = nn.Conv2d(64, out_channels, kernel_size=1, padding=0)    def forward(self, features):        # features is a dict of skip connections        bottleneck = features["bottleneck"]        d1 = self.dec1(bottleneck, features["enc3"])  # Example: using enc3 as skip        d2 = self.dec2(d1, features["enc2"])        d3 = self.dec3(d2, features["enc1"])        d4 = self.dec4(d3, features["x0"])        out = self.out(d4)        return out    # Segmentaion decoder using pre-trained fixed encoderclass SegmentationDecoder(nn.Module):    def __init__(self, out_channels):        super().__init__()        self.dec1 = ConvBlockUpsample(1024, 512)          self.dec2 = ConvBlockUpsample(512, 256)        self.dec3 = ConvBlockUpsample(256, 128)        self.dec4 = ConvBlockUpsample(128, 64)        self.dec5 = ConvBlockUpsample(64, 32)        self.out = nn.Conv2d(32, out_channels, kernel_size=1, padding=0)    def forward(self, features):        # features is a dict of skip connections        bottleneck = features['bottleneck']        d1 = self.dec1(bottleneck)  # Example: using enc3 as skip        d2 = self.dec2(d1)        d3 = self.dec3(d2)        d4 = self.dec4(d3)        out = self.out(d4)        return outclass SegmentationModel(nn.Module):    def __init__(self, encoder, decoder):        super().__init__()        self.encoder = encoder  # Already frozen        self.decoder = decoder  # Learns to do segmentation    def forward(self, x):        features = self.encoder(x)  # Returns dict: {x0, enc1, enc2, enc3, bottleneck}        seg_out = self.decoder(features)        return seg_outif __name__ == "__main__":    autoencoder = Autoencoder()    autoencoder.load_state_dict(torch.load("../saved_models/Autoencoder/run_008/model5.pth"))    # Freeze encoder weights    for param in autoencoder.encoder.parameters():        param.requires_grad = False    seg_model = SegmentationModel(autoencoder.encoder, SegmentationDecoderSkip(out_channels=2))    out = seg_model(torch.randn(1, 3, 256, 256)).detach().numpy()    print(out.shape)        